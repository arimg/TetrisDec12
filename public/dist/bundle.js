/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/canvas.js":
/*!***********************!*\
  !*** ./src/canvas.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\r\nvar utils = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\r\nvar consts = __webpack_require__(/*! ./consts.js */ \"./src/consts.js\");\r\n\r\n\r\nvar lineColor = consts.GRID_LINE_COLOR;\r\n\r\nvar boxBorderColor = consts.BOX_BORDER_COLOR;\r\n\r\n//Draw a single line in canvas context\r\nvar drawLine = function (ctx, p1, p2, color) {\r\n\tctx.beginPath();\r\n\tctx.moveTo(p1.x, p1.y);\r\n\tctx.lineTo(p2.x, p2.y);\r\n\r\n\tctx.lineWidth = 1;\r\n\tctx.strokeStyle = color;\r\n\r\n\tctx.stroke();\r\n\tctx.closePath();\r\n};\r\n\r\n\r\n//Draw game grids\r\nvar drawGrids = function (el, gridSize, colCount, rowCount, color1, color2) {\r\n\r\n\tvar ctx = el.getContext('2d');\r\n\tvar width = el.width;\r\n\tvar height = el.height;\r\n\r\n\tctx.rect(0, 0, width, height);\r\n\r\n\tvar grd = ctx.createLinearGradient(0, 0, 0, height);\r\n\tgrd.addColorStop(0, color1);\r\n\tgrd.addColorStop(1, color2);\r\n\tctx.fillStyle = grd;\r\n\tctx.fill();\r\n\r\n\r\n\tfor (var i = 1; i < colCount; i++) {\r\n\t\tvar x = gridSize * i + 0.5;\r\n\t\tdrawLine(ctx, { x: x, y: 0 }, { x: x, y: height }, lineColor);\r\n\t};\r\n\tfor (var i = 1; i < rowCount; i++) {\r\n\t\tvar y = gridSize * i + 0.5;\r\n\t\tdrawLine(ctx, { x: 0, y: y }, { x: width, y: y }, lineColor);\r\n\t};\r\n};\r\n\r\n//Draw box of shape (shape is the composition of boxes)\r\nvar drawBox = function (ctx, color, x, y, gridSize) {\r\n\tif (y < 0) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tctx.rect(x, y, gridSize, gridSize);\r\n\tctx.fillStyle = color;\r\n\tctx.fill();\r\n\tctx.strokeStyle = boxBorderColor;\r\n\tctx.lineWidth = 1;\r\n\tctx.stroke();\r\n\tctx.closePath();\r\n}\r\n\r\n/*\r\n\tCanvas main object, use to draw all games data.\r\n*/\r\nvar tetrisCanvas = {\r\n\r\n\tinit: function (scene, preview) {\r\n\t\tthis.scene = scene;\r\n\t\tthis.preview = preview;\r\n\t\tthis.sceneContext = scene.getContext('2d');\r\n\t\tthis.previewContext = preview.getContext('2d');\r\n\t\tthis.gridSize = scene.width / consts.COLUMN_COUNT;\r\n\r\n\t\tthis.previewGridSize = preview.width / consts.PREVIEW_COUNT;\r\n\r\n\t\tthis.drawScene();\r\n\r\n\t},\r\n\r\n\t//Clear game canvas\r\n\tclearScene: function () {\r\n\t\tthis.sceneContext.clearRect(0, 0, this.scene.width, this.scene.height);\r\n\t},\r\n\t//Clear preview canvas\r\n\tclearPreview: function () {\r\n\t\tthis.previewContext.clearRect(0, 0, this.preview.width, this.preview.height);\r\n\t},\r\n\t//Draw game scene, grids\r\n\tdrawScene: function () {\r\n\t\tthis.clearScene();\r\n\t\tdrawGrids(this.scene, this.gridSize,\r\n\t\t\tconsts.COLUMN_COUNT, consts.ROW_COUNT,\r\n\t\t\tconsts.SCENE_BG_START, consts.SCENE_BG_END);\r\n\t},\r\n\t//Draw game data\r\n\tdrawMatrix: function (matrix) {\r\n\t\tfor (var i = 0; i < matrix.length; i++) {\r\n\t\t\tvar row = matrix[i];\r\n\t\t\tfor (var j = 0; j < row.length; j++) {\r\n\t\t\t\tif (row[j] !== 0) {\r\n\t\t\t\t\tdrawBox(this.sceneContext, row[j], j * this.gridSize, i * this.gridSize, this.gridSize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t//Draw preview data\r\n\tdrawPreview: function () {\r\n\t\tdrawGrids(this.preview, this.previewGridSize,\r\n\t\t\tconsts.PREVIEW_COUNT, consts.PREVIEW_COUNT,\r\n\t\t\tconsts.PREVIEW_BG, consts.PREVIEW_BG);\r\n\t},\r\n\t//Draw acitve shape in game\r\n\tdrawShape: function (shape) {\r\n\t\tif (!shape) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar matrix = shape.matrix();\r\n\t\tvar gsize = this.gridSize;\r\n\t\tfor (var i = 0; i < matrix.length; i++) {\r\n\t\t\tfor (var j = 0; j < matrix[i].length; j++) {\r\n\t\t\t\tvar value = matrix[i][j];\r\n\t\t\t\tif (value === 1) {\r\n\t\t\t\t\tvar x = gsize * (shape.x + j);\r\n\t\t\t\t\tvar y = gsize * (shape.y + i);\r\n\t\t\t\t\tdrawBox(this.sceneContext, shape.color, x, y, gsize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t//Draw preview shape in preview canvas\r\n\tdrawPreviewShape: function (shape) {\r\n\t\tif (!shape) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.clearPreview();\r\n\t\tvar matrix = shape.matrix();\r\n\t\tvar gsize = this.previewGridSize;\r\n\t\tvar startX = (this.preview.width - gsize * shape.getColumnCount()) / 2;\r\n\t\tvar startY = (this.preview.height - gsize * shape.getRowCount()) / 2;\r\n\t\tfor (var i = 0; i < matrix.length; i++) {\r\n\t\t\tfor (var j = 0; j < matrix[i].length; j++) {\r\n\t\t\t\tvar value = matrix[i][j];\r\n\t\t\t\tif (value === 1) {\r\n\t\t\t\t\tvar x = startX + gsize * j;\r\n\t\t\t\t\tvar y = startY + gsize * i;\r\n\t\t\t\t\tdrawBox(this.previewContext, shape.color, x, y, gsize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n};\r\n\r\nmodule.exports = tetrisCanvas;\n\n//# sourceURL=webpack:///./src/canvas.js?");

/***/ }),

/***/ "./src/consts.js":
/*!***********************!*\
  !*** ./src/consts.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\r\n//colors for shapes\r\nvar colors = ['#00af9d', '#ffb652', '#cd66cc', '#66bc29', '#0096db', '#3a7dda', '#ffe100'];\r\n\r\n//sidebar width\r\nvar sideWidth = 300;\r\n\r\n\r\n//scene column count\r\nvar columnCount = 20;\r\n\r\n//scene row count;\r\nvar rowCount = 20;\r\n\r\n//previewCount\r\nvar previewCount = 6;\r\n\r\n//scene gradient start color \r\nvar sceneBgStart = '#8e9ba6';\r\n\r\n//scene gradient end color \r\nvar sceneBgEnd = '#5c6975';\r\n\r\n//preview background color\r\nvar previewBg = '#2f2f2f';\r\n\r\n//grid line color\r\nvar gridLineColor = 'rgba(255,255,255,0.2)';\r\n\r\n//box border color\r\nvar boxBorderColor = 'rgba(255,255,255,0.5)';\r\n\r\n\r\n// Game speed\r\nvar defaultInterval = 600;\r\n\r\n\r\n// Level update interval \r\nvar levelInterval = 120 * 1000;\r\n\r\n\r\n\r\nvar exports = module.exports = {};\r\n\r\nexports.COLORS = colors;\r\n\r\nexports.SIDE_WIDTH = sideWidth;\r\n\r\nexports.ROW_COUNT = rowCount;\r\n\r\nexports.COLUMN_COUNT = columnCount;\r\n\r\nexports.SCENE_BG_START = sceneBgStart;\r\n\r\nexports.SCENE_BG_END = sceneBgEnd;\r\n\r\nexports.PREVIEW_BG = previewBg;\r\n\r\nexports.PREVIEW_COUNT = previewCount;\r\n\r\nexports.GRID_LINE_COLOR = gridLineColor;\r\n\r\nexports.BOX_BORDER_COLOR = boxBorderColor;\r\n\r\nexports.DEFAULT_INTERVAL = defaultInterval;\r\n\r\nexports.LEVEL_INTERVAL = levelInterval;\r\n\n\n//# sourceURL=webpack:///./src/consts.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var utils = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\r\nvar consts = __webpack_require__(/*! ./consts.js */ \"./src/consts.js\");\r\nvar socketFunc = __webpack_require__(/*! ./socket.js */ \"./src/socket.js\");\r\nvar shapes = __webpack_require__(/*! ./shapes.js */ \"./src/shapes.js\");\r\nvar views = __webpack_require__(/*! ./views.js */ \"./src/views.js\");\r\nvar canvas = __webpack_require__(/*! ./canvas.js */ \"./src/canvas.js\");\r\n\r\n/**\r\n\tInit game matrix\r\n*/\r\nvar initMatrix = function (rowCount, columnCount) {\r\n\tvar result = [];\r\n\tfor (var i = 0; i < rowCount; i++) {\r\n\t\tvar row = [];\r\n\t\tresult.push(row);\r\n\t\tfor (var j = 0; j < columnCount; j++) {\r\n\t\t\trow.push(0);\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n};\r\n\r\n/**\r\n  Clear game matrix\r\n*/\r\nvar clearMatrix = function (matrix) {\r\n\tfor (var i = 0; i < matrix.length; i++) {\r\n\t\tfor (var j = 0; j < matrix[i].length; j++) {\r\n\t\t\tmatrix[i][j] = 0;\r\n\t\t}\r\n\t}\r\n};\r\n\r\n\r\n/**\r\n\tCheck all full rows in game matrix\r\n\treturn rows number array. eg: [18,19];\r\n*/\r\nvar checkFullRows = function (matrix) {\r\n\tvar rowNumbers = [];\r\n\tfor (var i = 0; i < matrix.length; i++) {\r\n\t\tvar row = matrix[i];\r\n\t\tvar full = true;\r\n\t\tfor (var j = 0; j < row.length; j++) {\r\n\t\t\tfull = full && row[j] !== 0;\r\n\t\t}\r\n\t\tif (full) {\r\n\t\t\trowNumbers.push(i);\r\n\t\t}\r\n\t}\r\n\r\n\treturn rowNumbers;\r\n};\r\n\r\n/**\r\n\tRemove one row from game matrix. \r\n\tcopy each previous row data to  next row  which row number less than row;\r\n*/\r\nvar removeOneRow = function (matrix, row) {\r\n\tvar colCount = matrix[0].length;\r\n\tfor (var i = row; i >= 0; i--) {\r\n\t\tfor (var j = 0; j < colCount; j++) {\r\n\t\t\tif (i > 0) {\r\n\t\t\t\tmatrix[i][j] = matrix[i - 1][j];\r\n\t\t\t} else {\r\n\t\t\t\tmatrix[i][j] = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n/**\r\n\tRemove rows from game matrix by row numbers.\r\n*/\r\nvar removeRows = function (matrix, rows) {\r\n\tfor (var i in rows) {\r\n\t\tremoveOneRow(matrix, rows[i]);\r\n\t}\r\n};\r\n\r\n/**\r\n\tCheck game data to determin wether the  game is over\r\n*/\r\nvar checkGameOver = function (matrix) {\r\n\tvar firstRow = matrix[0];\r\n\tfor (var i = 0; i < firstRow.length; i++) {\r\n\t\tif (firstRow[i] !== 0) {\r\n\t\t\treturn true;\r\n\t\t};\r\n\t}\r\n\treturn false;\r\n};\r\n\r\n\r\n/**\r\n\tCalculate  the extra rewards add to the score\r\n*/\r\nvar calcRewards = function (rows) {\r\n\tif (rows && rows.length > 1) {\r\n\t\treturn Math.pow(2, rows.length - 1) * 100;\r\n\t}\r\n\treturn 0;\r\n};\r\n\r\n/**\r\n\tCalculate game score\r\n*/\r\nvar calcScore = function (rows) {\r\n\tif (rows && rows.length) {\r\n\t\treturn rows.length * 100;\r\n\t}\r\n\treturn 0;\r\n};\r\n\r\n/**\r\n\tCalculate time interval by level, the higher the level,the faster shape moves\r\n*/\r\nvar calcIntervalByLevel = function (level) {\r\n\treturn consts.DEFAULT_INTERVAL - (level - 1) * 60;\r\n};\r\n\r\n\r\n// Default max scene size\r\nvar defaults = {\r\n\tmaxHeight: 700,\r\n\tmaxWidth: 600\r\n};\r\n\r\n/**\r\n\tTetris main object defination\r\n*/\r\nfunction Tetris(id, socket) {\r\n\tthis.id = id;\r\n\tthis.socket = socket;\r\n\tconsole.log(this.socket);\r\n\tthis.init();\r\n}\r\n\r\nTetris.prototype = {\r\n\r\n\tinit: function (options) {\r\n\t\tthis.socket.on(\"backend\", (data) => {\r\n\t\t\talert(data);\r\n\t\t});\r\n\r\n\t\tvar cfg = this.config = utils.extend(options, defaults);\r\n\t\tthis.interval = consts.DEFAULT_INTERVAL;\r\n\r\n\t\tviews.init(this.id, cfg.maxWidth, cfg.maxHeight);\r\n\r\n\t\tcanvas.init(views.scene, views.preview);\r\n\r\n\t\tthis.matrix = initMatrix(consts.ROW_COUNT, consts.COLUMN_COUNT);\r\n\t\tthis.reset();\r\n\r\n\t\tthis._initEvents();\r\n\t\tthis._fireShape();\r\n\r\n\t},\r\n\t//Reset game\r\n\treset: function () {\r\n\t\tthis.running = false;\r\n\t\tthis.isGameOver = false;\r\n\t\tthis.level = 1;\r\n\t\tthis.score = 0;\r\n\t\tthis.startTime = new Date().getTime();\r\n\t\tthis.currentTime = this.startTime;\r\n\t\tthis.prevTime = this.startTime;\r\n\t\tthis.levelTime = this.startTime;\r\n\t\tclearMatrix(this.matrix);\r\n\t\tviews.setLevel(this.level);\r\n\t\tviews.setScore(this.score);\r\n\t\tviews.setGameOver(this.isGameOver);\r\n\t\tthis._draw();\r\n\t},\r\n\t//Start game\r\n\tstart: function () {\r\n\t\tthis.running = true;\r\n\t\twindow.requestAnimationFrame(utils.proxy(this._refresh, this));\r\n\t},\r\n\t//Pause game\r\n\tpause: function () {\r\n\t\tthis.running = false;\r\n\t\tthis.currentTime = new Date().getTime();\r\n\t\tthis.prevTime = this.currentTime;\r\n\t},\r\n\t//Game over\r\n\tgamveOver: function () {\r\n\r\n\t},\r\n\t// All key event handlers\r\n\t_keydownHandler: function (e) {\r\n\r\n\t\tvar matrix = this.matrix;\r\n\r\n\t\tif (!e) {\r\n\t\t\tvar e = window.event;\r\n\t\t}\r\n\t\tif (this.isGameOver || !this.shape) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tswitch (e.keyCode) {\r\n\t\t\tcase 37: { this.shape.goLeft(matrix); this._draw(); }\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 39: { this.shape.goRight(matrix); this._draw(); }\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 38: { this.shape.rotate(matrix); this._draw(); }\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 40: { this.shape.goDown(matrix); this._draw(); }\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 32: { this.shape.goBottom(matrix); this._update(); }\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t},\r\n\t// Restart game\r\n\t_restartHandler: function () {\r\n\t\tthis.reset();\r\n\t\tthis.start();\r\n\t},\r\n\t// Bind game events\r\n\t_initEvents: function () {\r\n\t\twindow.addEventListener('keydown', utils.proxy(this._keydownHandler, this), false);\r\n\t\tviews.btnRestart.addEventListener('click', utils.proxy(this._restartHandler, this), false);\r\n\t},\r\n\r\n\t// Fire a new random shape\r\n\t_fireShape: function () {\r\n\t\tthis.shape = this.preparedShape || shapes.randomShape();\r\n\t\tthis.preparedShape = shapes.randomShape();\r\n\t\tthis._draw();\r\n\t\tcanvas.drawPreviewShape(this.preparedShape);\r\n\t},\r\n\r\n\t// Draw game data\r\n\t_draw: function () {\r\n\t\tcanvas.drawScene();\r\n\t\tcanvas.drawShape(this.shape);\r\n\t\tcanvas.drawMatrix(this.matrix);\r\n\t},\r\n\t// Refresh game canvas\r\n\t_refresh: function () {\r\n\t\tif (!this.running) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.currentTime = new Date().getTime();\r\n\t\tif (this.currentTime - this.prevTime > this.interval) {\r\n\t\t\tthis._update();\r\n\t\t\tthis.prevTime = this.currentTime;\r\n\t\t\tthis._checkLevel();\r\n\t\t}\r\n\t\tif (!this.isGameOver) {\r\n\t\t\twindow.requestAnimationFrame(utils.proxy(this._refresh, this));\r\n\t\t}\r\n\t},\r\n\t// Update game data\r\n\t_update: function () {\r\n\t\tif (this.shape.canDown(this.matrix)) {\r\n\t\t\tthis.shape.goDown(this.matrix);\r\n\t\t} else {\r\n\t\t\tthis.shape.copyTo(this.matrix);\r\n\t\t\tthis._check();\r\n\t\t\tthis._fireShape();\r\n\t\t}\r\n\t\tthis._draw();\r\n\t\tthis.isGameOver = checkGameOver(this.matrix);\r\n\t\tviews.setGameOver(this.isGameOver);\r\n\t\tif (this.isGameOver) {\r\n\t\t\tviews.setFinalScore(this.score);\r\n\t\t}\r\n\t},\r\n\t// Check and update game data\r\n\t_check: function () {\r\n\t\tvar rows = checkFullRows(this.matrix);\r\n\t\tif (rows.length) {\r\n\t\t\tremoveRows(this.matrix, rows);\r\n\r\n\t\t\tvar score = calcScore(rows);\r\n\t\t\tvar reward = calcRewards(rows);\r\n\t\t\tthis.score += score + reward;\r\n\r\n\t\t\tviews.setScore(this.score);\r\n\t\t\tviews.setReward(reward);\r\n\r\n\t\t}\r\n\t},\r\n\t// Check and update game level\r\n\t_checkLevel: function () {\r\n\t\tvar currentTime = new Date().getTime();\r\n\t\tif (currentTime - this.levelTime > consts.LEVEL_INTERVAL) {\r\n\t\t\tthis.level += 1;\r\n\t\t\tthis.interval = calcIntervalByLevel(this.level);\r\n\t\t\tviews.setLevel(this.level);\r\n\t\t\tthis.levelTime = currentTime;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nwindow.Tetris = Tetris;\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/shapes.js":
/*!***********************!*\
  !*** ./src/shapes.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var consts = __webpack_require__(/*! ./consts.js */ \"./src/consts.js\");\r\nvar COLORS = consts.COLORS;\r\nvar COLUMN_COUNT = consts.COLUMN_COUNT;\r\n\r\n/**\r\n\tDefined all shapes used in Tetris game. \r\n\tYou can add more shapes if you wish.\r\n*/\r\n\r\nfunction ShapeL() {\r\n\tvar state1 = [[1, 0],\r\n\t[1, 0],\r\n\t[1, 1]];\r\n\r\n\tvar state2 = [[0, 0, 1],\r\n\t[1, 1, 1]];\r\n\r\n\tvar state3 = [[1, 1],\r\n\t[0, 1],\r\n\t[0, 1]];\r\n\r\n\tvar state4 = [[1, 1, 1],\r\n\t[1, 0, 0]];\r\n\r\n\r\n\tthis.states = [state1, state2, state3, state4];\r\n\tthis.x = 4;\r\n\tthis.y = -3;\r\n\tthis.flag = 'L';\r\n}\r\n\r\nfunction ShapeLR() {\r\n\tvar state1 = [[0, 1],\r\n\t[0, 1],\r\n\t[1, 1]];\r\n\r\n\tvar state2 = [[1, 1, 1],\r\n\t[0, 0, 1]];\r\n\r\n\tvar state3 = [[1, 1],\r\n\t[1, 0],\r\n\t[1, 0]];\r\n\r\n\tvar state4 = [[1, 0, 0],\r\n\t[1, 1, 1]];\r\n\r\n\r\n\tthis.states = [state1, state2, state3, state4];\r\n\tthis.x = 4;\r\n\tthis.y = -3;\r\n\tthis.flag = 'LR';\r\n}\r\n\r\nfunction ShapeO() {\r\n\r\n\tvar state1 = [[1, 1],\r\n\t[1, 1]];\r\n\r\n\r\n\tthis.states = [state1];\r\n\tthis.x = 4;\r\n\tthis.y = -2;\r\n\tthis.flag = 'O';\r\n}\r\n\r\nfunction ShapeI() {\r\n\tvar state1 = [[1],\r\n\t[1],\r\n\t[1],\r\n\t[1]];\r\n\r\n\tvar state2 = [[1, 1, 1, 1]];\r\n\r\n\tthis.states = [state1, state2];\r\n\r\n\tthis.x = 5;\r\n\tthis.y = -4;\r\n\tthis.flag = 'I';\r\n}\r\n\r\nfunction ShapeT() {\r\n\tvar state1 = [[1, 1, 1],\r\n\t[0, 1, 0]];\r\n\r\n\tvar state2 = [[1, 0],\r\n\t[1, 1],\r\n\t[1, 0]];\r\n\r\n\tvar state3 = [[0, 1, 0],\r\n\t[1, 1, 1]];\r\n\r\n\tvar state4 = [[0, 1],\r\n\t[1, 1],\r\n\t[0, 1]];\r\n\r\n\tthis.states = [state1, state2, state3, state4];\r\n\tthis.x = 4;\r\n\tthis.y = -2;\r\n\tthis.flag = 'T';\r\n}\r\n\r\nfunction ShapeZ() {\r\n\tvar state1 = [[1, 1, 0],\r\n\t[0, 1, 1]];\r\n\r\n\tvar state2 = [[0, 1],\r\n\t[1, 1],\r\n\t[1, 0]];\r\n\r\n\tthis.states = [state1, state2];\r\n\tthis.x = 4;\r\n\tthis.y = -2;\r\n\tthis.flag = 'Z';\r\n}\r\n\r\nfunction ShapeZR() {\r\n\tvar state1 = [[0, 1, 1],\r\n\t[1, 1, 0]];\r\n\r\n\tvar state2 = [[1, 0],\r\n\t[1, 1],\r\n\t[0, 1]];\r\n\r\n\tthis.states = [state1, state2];\r\n\tthis.x = 4;\r\n\tthis.y = -2;\r\n\tthis.flag = 'ZR';\r\n}\r\n\r\n/**\r\nIs shape can move\r\n@param shape: tetris shape\r\n@param matrix: game matrix\r\n@param action:  'left','right','down','rotate'\r\n*/\r\nvar isShapeCanMove = function (shape, matrix, action) {\r\n\tvar rows = matrix.length;\r\n\tvar cols = matrix[0].length;\r\n\r\n\tvar isBoxCanMove = function (box) {\r\n\r\n\t\tvar x = shape.x + box.x;\r\n\t\tvar y = shape.y + box.y;\r\n\t\tif (y < 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (action === 'left') {\r\n\t\t\tx -= 1;\r\n\t\t\treturn x >= 0 && x < cols && matrix[y][x] == 0;\r\n\t\t} else if (action === 'right') {\r\n\t\t\tx += 1;\r\n\t\t\treturn x >= 0 && x < cols && matrix[y][x] == 0;\r\n\t\t} else if (action === 'down') {\r\n\t\t\ty += 1;\r\n\t\t\treturn y < rows && matrix[y][x] == 0;\r\n\t\t} else if (action === 'rotate') {\r\n\t\t\treturn y < rows && !matrix[y][x];\r\n\t\t}\r\n\t};\r\n\r\n\tvar boxes = action === 'rotate' ? shape.getBoxes(shape.nextState()) : shape.getBoxes(shape.state);\r\n\r\n\tfor (var i in boxes) {\r\n\t\tif (!isBoxCanMove(boxes[i])) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n};\r\n\r\n/**\r\n All shapes shares the same method, use prototype for memory optimized\r\n*/\r\nShapeL.prototype =\r\n\tShapeLR.prototype =\r\n\tShapeO.prototype =\r\n\tShapeI.prototype =\r\n\tShapeT.prototype =\r\n\tShapeZ.prototype =\r\n\tShapeZR.prototype = {\r\n\r\n\t\tinit: function () {\r\n\t\t\tthis.color = COLORS[Math.floor(Math.random() * 7)];\r\n\t\t\tthis.state = 0;\r\n\t\t\tthis.allBoxes = {};\r\n\t\t\tthis.y = 0;\r\n\t\t},\r\n\t\t// Get boxes matrix which composite the shape\r\n\t\tgetBoxes: function (state) {\r\n\r\n\t\t\tvar boxes = this.allBoxes[state] || [];\r\n\t\t\tif (boxes.length) {\r\n\t\t\t\treturn boxes;\r\n\t\t\t}\r\n\r\n\t\t\tvar matrix = this.matrix(state);\r\n\t\t\tfor (var i = 0; i < matrix.length; i++) {\r\n\t\t\t\tvar row = matrix[i];\r\n\t\t\t\tfor (var j = 0; j < row.length; j++) {\r\n\t\t\t\t\tif (row[j] === 1) {\r\n\t\t\t\t\t\tboxes.push({ x: j, y: i });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.allBoxes[state] = boxes;\r\n\t\t\treturn boxes;\r\n\t\t},\r\n\t\t//Get matrix for specified state\r\n\t\tmatrix: function (state) {\r\n\t\t\tvar st = state !== undefined ? state : this.state;\r\n\t\t\treturn this.states[st];\r\n\t\t},\r\n\t\t//Rotate shape\r\n\t\trotate: function (matrix) {\r\n\t\t\tif (isShapeCanMove(this, matrix, 'rotate')) {\r\n\t\t\t\tthis.state = this.nextState();\r\n\t\t\t\t//fix position if shape is out of right border\r\n\t\t\t\tvar right = this.getRight();\r\n\t\t\t\tif (right >= COLUMN_COUNT) {\r\n\t\t\t\t\tthis.x -= right - COLUMN_COUNT + 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t//Caculate the max column of the shape\r\n\t\tgetColumnCount: function () {\r\n\t\t\tvar mtx = this.matrix();\r\n\t\t\tvar colCount = 0;\r\n\t\t\tfor (var i = 0; i < mtx.length; i++) {\r\n\t\t\t\tcolCount = Math.max(colCount, mtx[i].length);\r\n\t\t\t}\r\n\t\t\treturn colCount;\r\n\t\t},\r\n\t\t//Caculate the max row of the shape\r\n\t\tgetRowCount: function () {\r\n\t\t\treturn this.matrix().length;\r\n\t\t},\r\n\t\t//Get the right pos of the shape\r\n\t\tgetRight: function () {\r\n\t\t\tvar boxes = this.getBoxes(this.state);\r\n\t\t\tvar right = 0;\r\n\r\n\t\t\tfor (var i in boxes) {\r\n\t\t\t\tright = Math.max(boxes[i].x, right);\r\n\t\t\t}\r\n\t\t\treturn this.x + right;\r\n\t\t},\r\n\t\t//Return the next state of the shape\r\n\t\tnextState: function () {\r\n\t\t\treturn (this.state + 1) % this.states.length;\r\n\t\t},\r\n\t\t//Check if the shape can move down\r\n\t\tcanDown: function (matrix) {\r\n\t\t\treturn isShapeCanMove(this, matrix, 'down');\r\n\t\t},\r\n\t\t//Move the shape down \r\n\t\tgoDown: function (matrix) {\r\n\t\t\tif (isShapeCanMove(this, matrix, 'down')) {\r\n\t\t\t\tthis.y += 1;\r\n\t\t\t}\r\n\t\t},\r\n\t\t//Move the shape to the Bottommost\r\n\t\tgoBottom: function (matrix) {\r\n\t\t\twhile (isShapeCanMove(this, matrix, 'down')) {\r\n\t\t\t\tthis.y += 1;\r\n\t\t\t}\r\n\t\t},\r\n\t\t//Move the shape to the left\r\n\t\tgoLeft: function (matrix) {\r\n\t\t\tif (isShapeCanMove(this, matrix, 'left')) {\r\n\t\t\t\tthis.x -= 1;\r\n\t\t\t}\r\n\t\t},\r\n\t\t//Move the shape to the right\r\n\t\tgoRight: function (matrix) {\r\n\t\t\tif (isShapeCanMove(this, matrix, 'right')) {\r\n\t\t\t\tthis.x += 1;\r\n\t\t\t}\r\n\t\t},\r\n\t\t//Copy the shape data to the game data\r\n\t\tcopyTo: function (matrix) {\r\n\t\t\tvar smatrix = this.matrix();\r\n\t\t\tfor (var i = 0; i < smatrix.length; i++) {\r\n\t\t\t\tvar row = smatrix[i];\r\n\t\t\t\tfor (var j = 0; j < row.length; j++) {\r\n\t\t\t\t\tif (row[j] === 1) {\r\n\t\t\t\t\t\tvar x = this.x + j;\r\n\t\t\t\t\t\tvar y = this.y + i;\r\n\t\t\t\t\t\tif (x >= 0 && x < matrix[0].length && y >= 0 && y < matrix.length) {\r\n\t\t\t\t\t\t\tmatrix[y][x] = this.color;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n/**\r\n\tCreate  a random shape for game\r\n*/\r\nfunction randomShape() {\r\n\tvar result = Math.floor(Math.random() * 7);\r\n\tvar shape;\r\n\r\n\tswitch (result) {\r\n\t\tcase 0: shape = new ShapeL(); break;\r\n\t\tcase 1: shape = new ShapeO(); break;\r\n\t\tcase 2: shape = new ShapeZ(); break;\r\n\t\tcase 3: shape = new ShapeT(); break;\r\n\t\tcase 4: shape = new ShapeLR(); break;\r\n\t\tcase 5: shape = new ShapeZR(); break;\r\n\t\tcase 6: shape = new ShapeI(); break;\r\n\t}\r\n\tshape.init();\r\n\treturn shape;\r\n}\r\n\r\nmodule.exports.randomShape = randomShape;\r\n\r\n\r\n/*\r\nShape: {\r\n\tcolor:    //int\r\n\r\n}\r\n*/\r\n\n\n//# sourceURL=webpack:///./src/shapes.js?");

/***/ }),

/***/ "./src/socket.js":
/*!***********************!*\
  !*** ./src/socket.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const startSocket = function () {\n\n}\n\nmodule.exports = {\n  startSocket: startSocket\n}\n\n//# sourceURL=webpack:///./src/socket.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\r\nvar exports = module.exports = {};\r\n\r\nvar $ = function (id) {\r\n    return document.getElementById(id);\r\n};\r\n\r\n\r\n\r\n//if object is plain object\r\nvar _isPlainObject = function (obj) {\r\n\r\n    if (typeof obj !== 'object') {\r\n        return false;\r\n    }\r\n\r\n\r\n    if (obj.constructor &&\r\n        !hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) {\r\n        return false;\r\n    }\r\n\r\n    // If the function hasn't returned already, we're confident that\r\n    // |obj| is a plain object, created by {} or constructed with new Object\r\n    return true;\r\n};\r\n\r\n// this method source code is from jquery 2.0.x\r\n// merge object's value and return\r\nvar extend = function () {\r\n    var src, copyIsArray, copy, name, options, clone,\r\n        target = arguments[0] || {},\r\n        i = 1,\r\n        length = arguments.length,\r\n        deep = true;\r\n\r\n    // Handle a deep copy situation\r\n    if (typeof target === 'boolean') {\r\n        deep = target;\r\n        // skip the boolean and the target\r\n        target = arguments[i] || {};\r\n        i++;\r\n    }\r\n\r\n    // Handle case when target is a string or something (possible in deep copy)\r\n    if (typeof target !== 'object' && typeof obj !== 'function') {\r\n        target = {};\r\n    }\r\n\r\n\r\n    if (i === length) {\r\n        target = this;\r\n        i--;\r\n    }\r\n\r\n    for (; i < length; i++) {\r\n        // Only deal with non-null/undefined values\r\n        if ((options = arguments[i]) != null) {\r\n            // Extend the base object\r\n            for (name in options) {\r\n                src = target[name];\r\n                copy = options[name];\r\n\r\n                // Prevent never-ending loop\r\n                if (target === copy) {\r\n                    continue;\r\n                }\r\n                // Recurse if we're merging plain objects or arrays\r\n                if (deep && copy && (_isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\r\n                    if (copyIsArray) {\r\n                        copyIsArray = false;\r\n                        clone = src && Array.isArray(src) ? src : [];\r\n\r\n                    } else {\r\n                        clone = src && _isPlainObject(src) ? src : {};\r\n                    }\r\n\r\n                    // Never move original objects, clone them\r\n                    //console.log('abc');\r\n\r\n                    target[name] = extend(deep, clone, copy);\r\n\r\n                    // Don't bring in undefined values\r\n                } else if (copy !== undefined) {\r\n                    target[name] = copy;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Return the modified object\r\n    return target;\r\n};\r\n\r\n\r\nvar proxy = function (fn, context) {\r\n    var args = [].slice.call(arguments, 2);\r\n    proxy = function () {\r\n        return fn.apply(context || this, args.concat([].slice.call(arguments)));\r\n    };\r\n    return proxy;\r\n};\r\n\r\nvar aniFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||\r\n    window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\r\nwindow.requestAnimationFrame = aniFrame;\r\n\r\n\r\nexports.$ = $;\r\nexports.extend = extend;\r\nexports.proxy = proxy;\r\n\n\n//# sourceURL=webpack:///./src/utils.js?");

/***/ }),

/***/ "./src/views.js":
/*!**********************!*\
  !*** ./src/views.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n All dom definitions and actions\r\n*/\r\nvar utils = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\r\nvar consts = __webpack_require__(/*! ./consts.js */ \"./src/consts.js\");\r\n\r\nvar $ = utils.$;\r\n\r\n//doms\r\nvar scene = $('scene');\r\nvar side = $('side');\r\nvar info = $('info');\r\nvar preview = $('preview');\r\nvar level = $('level');\r\nvar score = $('score');\r\nvar rewardInfo = $('rewardInfo');\r\nvar reward = $('reward');\r\nvar gameOver = $('gameOver');\r\nvar btnRestart = $('restart');\r\nvar finalScore = $('finalScore');\r\n\r\n\r\n//defaults\r\nvar SIDE_WIDTH = consts.SIDE_WIDTH;\r\n\r\n\r\n/**\r\n\tCaculate the game container size\r\n*/\r\nvar getContainerSize = function(maxW,maxH){\r\n\r\n\tvar dw = document.documentElement.clientWidth;\r\n\tvar dh = document.documentElement.clientHeight;\r\n\r\n\tvar size = {};\r\n\tif (dw>dh){\r\n\t\tsize.height = Math.min(maxH,dh);\r\n\t\tsize.width = Math.min(size.height /2 + SIDE_WIDTH,maxW);\r\n\t}else{\r\n\t\tsize.width = Math.min(maxW,dw);\r\n\t\tsize.height =  Math.min(maxH,dh);\r\n\t}\r\n\treturn size;\r\n\r\n};\r\n\r\n\r\n/**\r\n\tLayout game elements\r\n*/\r\nvar layoutView = function(container,maxW,maxH){\r\n\tvar size = getContainerSize(maxW,maxH);\r\n\tvar st = container.style;\r\n\tst.height = size.height + 'px';\r\n\tst.width = size.width + 'px';\r\n\tst.marginTop = (-(size.height/2)) + 'px';\r\n\tst.marginLeft = (-(size.width/2)) + 'px';\r\n\r\n\t//layout scene\r\n\tscene.height = size.height;\r\n\tscene.width = scene.height / 2;\r\n\r\n\tvar sideW = size.width - scene.width;\r\n\tside.style.width = sideW+ 'px';\r\n\tif (sideW< SIDE_WIDTH ){\r\n\t\tinfo.style.width = side.style.width;\r\n\t}\r\n\tpreview.width = 80;\r\n\tpreview.height = 80;\r\n\r\n\tgameOver.style.width = scene.width +'px';\r\n\r\n}\r\n\r\n/**\r\n\tMain tetris game view\r\n*/\r\nvar tetrisView = {\r\n\r\n\r\n\tinit:function(id, maxW,maxH){\r\n\t  this.container = $(id);\r\n\t  this.scene = scene;\r\n\t  this.preview = preview;\r\n\t  this.btnRestart = btnRestart;\r\n\t  layoutView(this.container,maxW,maxH);\r\n\t  this.scene.focus();\r\n\r\n\t  rewardInfo.addEventListener('animationEnd',function(e){\r\n\t\t rewardInfo.className = 'invisible';\r\n\t  });\r\n\t},\r\n\t// Update the score \r\n\tsetScore:function(scoreNumber){\r\n\t\tscore.innerHTML = scoreNumber;\t\r\n\t},\r\n\t// Update the finnal score\r\n\tsetFinalScore:function(scoreNumber){\r\n\t\tfinalScore.innerHTML = scoreNumber;\r\n\t},\r\n\t// Update the level\r\n\tsetLevel:function(levelNumber){\r\n\t\tlevel.innerHTML = levelNumber;\r\n\t},\r\n\t// Update the extra reward score\r\n\tsetReward:function(rewardScore){\r\n\t\tif (rewardScore>0){\r\n\t\t\treward.innerHTML = rewardScore;\r\n\t\t\trewardInfo.className = 'fadeOutUp animated';\t\r\n\t\t}else{\r\n\t\t\trewardInfo.className = 'invisible';\r\n\t\t}\r\n\t},\r\n\t// Set game over view\r\n\tsetGameOver:function(isGameOver){\r\n\t\tgameOver.style.display = isGameOver?'block':'none';\r\n\t}\r\n};\r\n\r\nmodule.exports = tetrisView;\n\n//# sourceURL=webpack:///./src/views.js?");

/***/ })

/******/ });